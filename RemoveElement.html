<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remove Element</title>
    <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
</head>

<body>
    <h1>Leetcode #27: Remove Element:</h1>
    <h3>Directions:</h3>
    <p>Remove a given element from an array of integers in-place.</p>
    <p>Return a number representing the new count of the array</p>
    <h3>Results of code can be found in developer tools.</h3>
    <script>
        //Description: Remove given element(s) in-place from an array
        //Description: Non-swapped elements should all be in first part of array
        //Description: Return length of array after removal(s)
        //Constraints: Array length: 0..100
        //Constraints: Range of numbers in array: 0..50
        //Constraints: Value to find 0..100 -> target larger than array range
        //Note: upper range of val (51..100) should be out of range of possible array values (0..50)
        //Will implement an early return for val > 50 and see if it passes submission. Note..it did work.
        /**
        * @param {number[]} nums
        * @param {number} val
        * @return {number} //elements in array after removal(s)
        */
        /*
        Runtime: 109 ms, faster than 11.66% of JavaScript online submissions for Remove Element.
        Memory Usage: 41.6 MB, less than 97.75% of JavaScript online submissions for Remove Element.
        */
        var removeElement = function (nums, val) {
            //Pseuocode:
            //Create variable index to run loop
            //Create variable tail to track where substitutions ought to occur
            //Create variable removals to count each val found (for return value)

            //**logic**
            //if nums.length < 1: return 0;
            //if val > 50: return nums.length since no removals occurred
            //while index < nums.length
            //if val not found at index && index == tail: (no vals found yet)
            //  increment both index and tail
            //if val not found at index && index != tail: (vals found previously)
            //  copy element at index into tail
            //  set element at index to null since it's been swapped
            //  increment both index and tail
            //
            //if val is found at index:
            //  set element at index to null
            //  increment index
            //  increment removals
            //
            //return index - removals

            let index = 0;
            let tail = 0;
            let removals = 0;

            //shortcut returns
            if (nums.length < 1) return 0;
            if (val > 50) return nums.length;

            while (index < nums.length) {
                if (nums[index] != val && index == tail) {        //value not found yet
                    index++;
                    tail++
                }
                else if (nums[index] != val && index != tail) {   //value found before, but not this time
                    nums[tail] = nums[index];
                    nums[index] = null;
                    index++;
                    tail++;
                }
                else {                                            //value found
                    nums[index] = null;
                    index++;
                    removals++;
                }
            }
            return (index - removals);

        };

        //Experiments
        // console.log(removeElement([], 25));
        // console.log(removeElement([1, 2, 3, 4, 5], 51));
        // console.log(removeElement([3, 2, 2, 3], 3));
        // console.log(removeElement([0, 1, 2, 2, 3, 0, 4, 2], 2));
        // console.log(removeElement([3, 2, 2, 3], 3));
        // console.log(removeElement([1], 1));

    </script>

    <!-- Version 2.0 -->
    <script>
        //Simpler Strategy to address runtime performance using fast-runner and slow-runner
        //Runtime: 63 ms, faster than 84.56% of JavaScript online submissions for Remove Element.
        //Memory Usage: 41.9 MB, less than 83.25% of JavaScript online submissions for Remove Element.
        var removeElement = function (nums, val) {
            //slow-runner (i) and fast-runner (j)
            //slow-runner iterates ONLY when element-to-remove (val) not found
            let i = 0;
            for (let j = 0; j < nums.length; j++) {
                if (nums[j] != val) { //Val not found: copy fast-runner into slow-runner and iterate slow-runner
                    nums[i] = nums[j];
                    i++;
                }
            }
            return i;
        }

        //Experiments
        console.log(removeElement([], 25));
        console.log(removeElement([1, 2, 3, 4, 5], 51));
        console.log(removeElement([3, 2, 2, 3], 3));
        console.log(removeElement([0, 1, 2, 2, 3, 0, 4, 2], 2));
        console.log(removeElement([3, 2, 2, 3], 3));
        console.log(removeElement([1], 1));
    </script>
</body>

</html>